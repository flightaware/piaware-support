#!/usr/bin/env python3

from piaware_config import get_standard_config_group, ConfigGroup
from uuid import uuid4
import subprocess
import os
import stat
import ipaddress

SYS_CON_DIR = "/etc/NetworkManager/system-connections"

def netmask_to_cidr(netmask: str) -> int:
    return ipaddress.IPv4Network('0.0.0.0/' + netmask).prefixlen

# We're calculating broadcast address for an ipv4 address.
# Hence the magic number 32. Ipv4 addresses are 32 bits.
def calculate_brd_by_hand(addr: str, nm: int) -> str:
    values = addr.split(".")
    binaries = [f"{int(v):08b}" for v in values]
    full_bin = list("".join(binaries))
    for i in range(32 - nm):
        full_bin[i + nm] = "1"

    cur = ""
    base_10_val = []
    for index, i in enumerate(full_bin):
        cur += i

        if (index + 1) % 8 == 0 and index > 0:
            base_10_val.append(f"{(int(cur, 2))}")
            cur = ""

    ba = ".".join(base_10_val)
    return ba

def verify_broadcast_address(network: str,config: ConfigGroup) -> bool:
    assigned_ba = config.get(f"{network}-broadcast")
    if not assigned_ba:
        return False

    print("Verifying broadcast address")
    addr = config.get(f"{network}-address")

    if addr is None:
        print(f"Addr not set")
        return False

    nm = get_netmask(network, config)
    nm = netmask_to_cidr(nm)

    calculated_ba = calculate_brd_by_hand(addr, nm)

    if assigned_ba != calculated_ba:
        print(f"Warning: the brd address that we've calculated: {calculated_ba} is different than the one you've assigned: {assigned_ba}")
    
    return assigned_ba == calculated_ba

def format_dns(dns_string: str) -> str:
    names = dns_string.split()
    formatted = ";".join(names) + ";"
    return formatted

def check_address(network_type: str, config: ConfigGroup):
    address = config.get(f"{network_type}-address")
    if address is None:
        raise ValueError(f"{network_type}-type was set to static but {network_type}-address was not set")
    address = ipaddress.ip_address(address)

    if address.version != 4:
        raise ValueError(f"{network_type}-address needs an ipv4 address")

def get_netmask(network_type: str, config: ConfigGroup) -> str:
    netmask = config.get(f"{network_type}-netmask") 
    if netmask is None:
        address = config.get(f"{network_type}-address")
        address = ipaddress.ip_address(address)
        address = '{:#b}'.format(address)
        address = address[2:]
        match address[0:3]:
            case "000":
                return "255.0.0.0"
            case "100":
                return "255.255.0.0"
            case "110":
                return "255.255.255.0"
    else:
        return netmask

def configure_static_network(network_type: str, config: ConfigGroup) -> str:
    check_address(network_type, config)
    nm = get_netmask(network_type, config)
    cidr = str(netmask_to_cidr(nm))
    ip = ""
    static_ip = config.get(f"{network_type}-address") + "/" + cidr
    gateway = config.get(f"{network_type}-gateway")
    if gateway is not None:
        static_ip += f",{gateway}"
    ip += f"address1={static_ip}\n"

    name_servers = config.get(f"{network_type}-nameservers")
    if name_servers is not None:
        ip += f"dns={format_dns(name_servers)}\n"
    return ip

def get_wired_conn_file(config: ConfigGroup):
    new_uuid = uuid4()
    connect = "true" if config.get("wired-network") else "false"

    file = f"""
[connection]
id=wired
uuid={new_uuid}
type=ethernet
autoconnect-priority=999
interface-name=eth0
autoconnect={connect}

[ethernet]
"""
    ipv4 = """
[ipv4]
"""
    if config.get("wired-type") == "static":
        ipv4 += configure_static_network("wired", config)
        ipv4 += "method=manual\n"
    else:
        ipv4 += "method=auto\n"
    file += ipv4
    file += """
[ipv6]
addr-gen-mode=default
method=auto

[proxy]
"""

    return file

def get_wireless_conn_file(config: ConfigGroup):
    new_uuid = uuid4()
    ssid = config.get("wireless-ssid")
    psk = config.get("wireless-password")
    connect = "true" if config.get("wireless-network") else "false"

    file = f"""
[connection]
id=wireless
uuid={new_uuid}
type=wifi
autoconnect={connect}

[wifi]
mode=infrastructure
ssid={ssid}

[wifi-security]
key-mgmt=wpa-psk
psk={psk}
"""

    ipv4 = """
[ipv4]
"""
    if config.get("wireless-type") == "static":
        ipv4 += configure_static_network("wireless", config)
        ipv4 += f"method=manual\n"
    else:
        ipv4 += "method=auto\n"

    ipv4 += """
[ipv6]
addr-gen-mode=default
method=auto

[proxy]
"""
    file += ipv4
    return file

def generate_wired_network_config(config: ConfigGroup):
    with open(f"{SYS_CON_DIR}/wired.nmconnection", "w") as conn_file:
        conn_file.write(get_wired_conn_file(config))

    os.chmod(f"{SYS_CON_DIR}/wired.nmconnection", stat.S_IRUSR | stat.S_IWUSR)

def generate_wireless_network_config(config: ConfigGroup):
    with open(f"{SYS_CON_DIR}/wireless.nmconnection", "w") as conn_file:
        conn_file.write(get_wireless_conn_file(config))

    os.chmod(f"{SYS_CON_DIR}/wireless.nmconnection", stat.S_IRUSR | stat.S_IWUSR)
    
def main(dryrun=False, extra_file_path: str = None):
    config_group = get_standard_config_group(extra_file_path)
    generate_wired_network_config(config_group)
    generate_wireless_network_config(config_group)
    verify_broadcast_address("wireless", config_group)
    verify_broadcast_address("wired", config_group)

if __name__ == "__main__":
    main()